(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{369:function(t,a,s){"use strict";s.r(a);var e=s(12),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-命令简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-命令简介"}},[t._v("#")]),t._v(" 1.命令简介")]),t._v(" "),a("p",[t._v("strip 命令是 "),a("a",{attrs:{href:"https://www.gnu.org/software/binutils/",target:"_blank",rel:"noopener noreferrer"}},[t._v("GNU Binutils"),a("OutboundLink")],1),t._v(" 中的一员，用于剥掉目标文件中一些符号信息和调试信息，使文件变小。")]),t._v(" "),a("h2",{attrs:{id:"_2-命令格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-命令格式"}},[t._v("#")]),t._v(" 2.命令格式")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("strip [-F bfdname |--target=bfdname]\n      [-I bfdname |--input-target=bfdname]\n      [-O bfdname |--output-target=bfdname]\n      [-s|--strip-all]\n      [-S|-g|-d|--strip-debug]\n      [--strip-dwo]\n      [-K symbolname |--keep-symbol=symbolname]\n      [-N symbolname |--strip-symbol=symbolname]\n      [-w|--wildcard]\n      [-x|--discard-all] [-X |--discard-locals]\n      [-R sectionname |--remove-section=sectionname]\n      [-o file] [-p|--preserve-dates]\n      [-D|--enable-deterministic-archives]\n      [-U|--disable-deterministic-archives]\n      [--keep-file-symbols]\n      [--only-keep-debug]\n      [-v |--verbose] [-V|--version]\n      [--help] [--info]\n      objfile...\n")])])]),a("h2",{attrs:{id:"_3-选项说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-选项说明"}},[t._v("#")]),t._v(" 3.选项说明")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("[-F bfdname |--target=bfdname]：使用指定的二进制文件格式（Binary Format Descriptor）解析输入的目标文件，输出目标文件时也采用相同的格式\n[-I bfdname |--input-target=bfdname]：使用指定的二进制文件格式（Binary Format Descriptor）解析输入的目标文件\n[-O bfdname |--output-target=bfdname]：使用指定的二进制文件格式（Binary Format Descriptor）输出目标文件\n[-s|--strip-all]：删除所有符号\n[-S|-g|-d|--strip-debug]：仅删除调试符号\n[--strip-dwo]：删除所有DWARF .dwo节的内容，保留其余调试节和所有符号不变\n[-K symbolname |--keep-symbol=symbolname]：保留源文件中指定的符号symbolname\n[-N symbolname |--strip-symbol=symbolname]：从源文件中删除符号symbolname。此选项可能不止一次\n[-w|--wildcard]：允许在其他命令行选项中对符号名称使用正则表达式。问号（？）、星号（*）、反斜杠（\\）和方括号（[]）运算符可以在符号名的任何位置使用\n[-x|--discard-all]：删除非全局符号\n[-X |--discard-locals]：删除编译器生成的本地符号\n[-R sectionname |--remove-section=sectionname]：从输出文件中删除名为sectionname的任何节。此选项可能会给出多次。请注意，不适当地使用此选项可能会使输出文件不可用。通配符*可以在sectionname的末尾给出。如果是这样，则将删除以sectionname开头的任何节\n[-o file]：将剥离的输出放入文件 file 中，而不是替换现有文件。使用此参数时，只能指定一个objfile\n[-p|--preserve-dates]：保留文件的访问和修改日期\n[-D|--enable-deterministic-archives]：以确定性模式（deterministic mode）操作。复制存档成员和写入存档索引时，对UIDs、GIDs、时间戳使用零，对所有文件使用一致的文件模式\n[-U|--disable-deterministic-archives]：不以确定性模式（deterministic mode）操作。这与上面的-D选项相反：复制存档成员并写入存档索引时，使用它们的实际UID、GID、时间戳和文件模式值\n[--keep-file-symbols]：保留符号信息\n[--only-keep-debug]：保留调试信息\n[-v |--verbose] ：详细输出：列出所有修改的对象文件。对于归档文件，strip-v 列出了归档文件的所有成员\n[-V|--version]：显示版本信息\n[-h|--help]：显示帮助信息\n[--info]：列出支持的目标文件格式和架构\nobjfile...：目标文件，包括库文件或可执行文件\n")])])]),a("h2",{attrs:{id:"_4-常用示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-常用示例"}},[t._v("#")]),t._v(" 4.常用示例")]),t._v(" "),a("p",[t._v("先看一个 C++ 源码文件 main.cpp。")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//@file：main.cpp")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<iostream>")])]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("cout"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"strip"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("endl"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("使用 g++ 编译生成可执行文件 main.out。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("g++ "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" main.out main.cpp\nll\n-rw-r--r-- "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" root root     "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("68")]),t._v(" Mar "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("22")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),t._v(":55 main.cpp\n-rwxr-xr-x "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" root root   "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9119")]),t._v(" Mar "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("22")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),t._v(":55 main.out\n")])])]),a("p",[t._v("（1）剥掉可执行文件中一些符号信息和调试信息，使文件变小。")]),t._v(" "),a("p",[t._v("首先使用file命令来查看可执行文件main.out的基本信息，可见其是not stripped。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("file main.out \nmain.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=9d0d7d3718cf9a4cfdc3e026de804e2428bb60fa, not stripped\n")])])]),a("p",[t._v("然后使用 nm 命令来查看 main.out 中的符号。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("nm main.out\n000000000060105c B __bss_start\n0000000000601170 b completed.6337\n                 U __cxa_atexit@@GLIBC_2.2.5\n0000000000601058 D __data_start\n0000000000601058 W data_start\n00000000004007b0 t deregister_tm_clones\n0000000000400820 t __do_global_dtors_aux\n0000000000600de8 t __do_global_dtors_aux_fini_array_entry\n0000000000400978 R __dso_handle\n0000000000600df8 d _DYNAMIC\n000000000060105c D _edata\n...\n")])])]),a("p",[t._v("使用 strip 来剥掉 main.out 中的符号信息，并查看大小，文件基本信息和符号信息。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("strip main.out\n\nll main.out\n-rwxr-xr-x "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" root root "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6272")]),t._v(" Mar "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("22")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),t._v(":14 main.out\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("file")]),t._v(" main.out\nmain.out: ELF "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("64")]),t._v("-bit LSB executable, x86-64, version "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SYSV"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(", dynamically linked "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("uses shared libs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(", "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" GNU/Linux "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.6")]),t._v(".32, BuildID"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("sha1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("9d0d7d3718cf9a4cfdc3e026de804e2428bb60fa, stripped\n\nnm main.out\nnm: main.out: no symbols\n")])])]),a("p",[t._v("可见 main.out 大小从 9119 字节变为 6272 字节，且 file 命令显示文件状态为 stripped，使用 nm 命令显示 main.out 已经没有符号了。")]),t._v(" "),a("h2",{attrs:{id:"_5-小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-小结"}},[t._v("#")]),t._v(" 5.小结")]),t._v(" "),a("p",[t._v("通过上面的例子可以看出，strip 命令可用于剥掉目标文件的符号，使文件变小，这就节省了很多空间。")]),t._v(" "),a("p",[t._v("其实，strip 不仅仅针对可执行文件，还能针对目标文件和静态、动态库等。在实际的开发中，经常需要对动态库 .so 进行 strip 操作以减少空间。而在调试的时候（比如用 addr2line），就需要符号了。因此，通常的做法是用 strip 前的库调试，strip 后的库发布，发布的 strip 后的库一旦出了问题， 可以找对应未 strip 的库来定位。")]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"参考文献"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[t._v("#")]),t._v(" 参考文献")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.gnu.org/software/binutils/",target:"_blank",rel:"noopener noreferrer"}},[t._v("GNU Binutils"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"http://man7.org/linux/man-pages/man1/strip.1.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("strip(1) - Linux manual page - man7.org"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/qq_37858386/article/details/78559490",target:"_blank",rel:"noopener noreferrer"}},[t._v("linux中的strip命令简介"),a("OutboundLink")],1)]),t._v(" "),a("Vssue",{attrs:{title:"strip"}})],1)}),[],!1,null,null,null);a.default=n.exports}}]);
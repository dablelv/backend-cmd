(window.webpackJsonp=window.webpackJsonp||[]).push([[187],{520:function(t,a,s){"use strict";s.r(a);var n=s(12),e=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-命令简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-命令简介"}},[t._v("#")]),t._v(" 1.命令简介")]),t._v(" "),a("p",[t._v("g++ 是 GNU 开发的 C++ 编译器，是 GNU 编译器套件 GCC（GNU Compiler Collection）的组成部分。")]),t._v(" "),a("p",[t._v("注意 gcc 是 GNU 的 C 编译器，不要与 g++ 混为一谈。")]),t._v(" "),a("p",[t._v("看官方手册你会发现 g++ 的命令选项真的多如繁星，令人头皮发麻。但是常用的命令选项也就那几个，足以完成日常编译，g++ 使用起来还是比较简单的！")]),t._v(" "),a("p",[t._v("g++ 编译器是 GCC 的一部分，GCC 编译工作一般分为四个步骤。考察如下简单的 C++ 程序。")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<iostream>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("using")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("namespace")]),t._v(" std"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tcout"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello world"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("endl"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("下面分别进行预处理、编译、汇编和链接，将 C++ 源码文件 test.cpp 转换为可执行文件 test.out。")]),t._v(" "),a("p",[t._v("（1）预处理（Preprocessing）。")]),t._v(" "),a("p",[t._v("由预处理器 cpp 完成，将 .cpp 源文件预处理为 .i 文件。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#生成预处理后的.i文件")]),t._v("\ng++ "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-E")]),t._v(" test.cpp "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" test.i\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#或")]),t._v("\ncpp test.cpp "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" test.i\n")])])]),a("p",[t._v("（2）编译（Compilation）。")]),t._v(" "),a("p",[t._v("编译过程就是把预处理完的文件进行一系列语法分析、词法分析、语义分析及优化后产生相应的汇编代码。编译是整个程序构建过程中最为核心的部分，也是最复杂的部分之一。由编译器 cc1plus 完成，将 .i 文件编译为 .s 的汇编文件。使用 -S 选项，只进行编译而不进行汇编，生成汇编代码。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#生成汇编.s文件")]),t._v("\ng++ "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-S")]),t._v(" test.i "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" test.s\t\t\t\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#或")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ln")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-s")]),t._v(" /usr/libexec/gcc/x86_64-redhat-linux/4.8.2/cc1plus /usr/local/bin\ncc1plus test.i "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" test.s\n")])])]),a("p",[t._v("注意，GCC 编译套件中，C++ 的编译器是 cc1plus，C 是 cc1，Objective-C 是 cc1obj，Fortran 是 f771，Java 是 jc1。所以 g++ 这个命令是对预处理器、编译器、汇编器和链接器的包装，会根据不同的参数去调用这些构建程序。")]),t._v(" "),a("p",[t._v("（3）汇编（Assembly）。")]),t._v(" "),a("p",[t._v("由汇编器 as 完成，将 .s 文件汇编成 .o 的二进制目标文件。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#生成二进制.o文件")]),t._v("\ng++ "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-c")]),t._v(" test.s "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" test.o\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#或")]),t._v("\nas test.s "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" test.o\n")])])]),a("p",[t._v("（4）链接（Linking）")]),t._v(" "),a("p",[t._v("由链接器 ld，将 .o 文件链接成可执行程序。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("// 生成二进制.out可执行文件\ng++ test.o "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" test.out\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#或者直接使用ld进行链接，但是需要注意使用ld需添加较长命令选项。使用g++ -v选项可以查看最后一行collect2使用的命令选项。collect2是对ld的封装，最终还是要调用ld来完成链接工作。")]),t._v("\nld -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib64/crt1.o /usr/lib64/crti.o /usr/lib64/crtn.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5 -L/usr/lib64 -L/usr/lib -lstdc++ "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-lm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-lgcc_s")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-lc")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-lgcc")]),t._v("  main.o "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" test.out\n")])])]),a("p",[t._v("执行最后链接生成的 test.out 输出：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("hello world\n")])])]),a("h2",{attrs:{id:"_2-命令格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-命令格式"}},[t._v("#")]),t._v(" 2.命令格式")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("gcc "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-c"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("-S"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("-E"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-std"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("standard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-g"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-pg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-Olevel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-Wwarn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-pedantic"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-Idir"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-Ldir"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-Dmacro"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("defn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-Umacro"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-foption"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-mmachine-option"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("-o outfile"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("@file"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" infile"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n")])])]),a("h2",{attrs:{id:"_3-命令选项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-命令选项"}},[t._v("#")]),t._v(" 3.命令选项")]),t._v(" "),a("p",[t._v("关于 g++ 的命令选项，大家可以参考 "),a("a",{attrs:{href:"https://gcc.gnu.org/onlinedocs/gcc-6.1.0/gcc.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("GCC 官方手册"),a("OutboundLink")],1),t._v("，或者使用"),a("code",[t._v("man g++")]),t._v("查看 g++ 使用手册。")]),t._v(" "),a("p",[t._v("下面列出常用的命令选项。")]),t._v(" "),a("p",[t._v("（1）总体选项")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-E")]),t._v("\n\t只激活预处理，这个不生成文件,你需要把它重定向到一个输出文件里面。例子用法:   \n\tgcc "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-E")]),t._v(" hello.c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" pianoapan.txt   \n\tgcc "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-E")]),t._v(" hello.c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("more")]),t._v("   \n\t一句 "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello word"')]),t._v(" 预处理后能达到 "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("800")]),t._v(" 行代码。     \n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-S")]),t._v("   \n\t只激活预处理和编译，就是指把文件编译成为汇编代码。例子用法： \n\tgcc "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-S")]),t._v(" hello.c   \n\t将生成.s的汇编代码，可以用文本编辑器查看。    \n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-c")]),t._v("    \n\t只激活预处理,编译,和汇编,也就是他只把程序做成obj文件。例子用法:   \n\tgcc "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-c")]),t._v(" hello.c   \n\t将生成.o的目标文件（object file）。 \n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v("\n\t指定目标名称，缺省的时候，gcc/g++编译出来的文件是a.out。例子如下：   \n\tg++ "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" hello.out hello.cpp\n\tg++ "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" hello.asm "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-S")]),t._v(" hello.cpp   \n")])])]),a("p",[t._v("（2）目录选项")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("-I"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("dir"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t在你是用"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('#include "file"的时候，gcc/g++会先在当前目录查找你所指定的头文件，如果没有找到，会到系统默认的头文件目录找。如果使用-I指定了目录，编译器会先在指定的目录查找，然后再去系统默认头文件目录查找。对于#include <file>，gcc/g++会到-I指定的目录查找，查找不到，然后再到系统默认的头文件目录查找。')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("file"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t相当于“"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#include”，用于包含某个代码,简单来说,就是编译某个文件,需要另一个文件的时候,就可以   ")]),t._v("\n\t用它设定,功能就相当于在代码中使用"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#include。例子用法:   ")]),t._v("\n\tgcc hello.c "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-include")]),t._v(" /root/pianopan.h   \n-I-\n\t就是取消前一个参数的功能,所以一般在-Idir之后使用   \n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-idirafter")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("dir"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("   \n\t在-I的目录里面查找失败，将到目录dir里面查找。\n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-iprefix")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("prefix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("，-iwithprefix "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("dir"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t一般一起使用，当-I的目录查找失败，会到prefix+dir下查找。\n-L"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("dir"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t编译的时候，指定搜索库的路径。比如你自己的库，可以用它指定目录，不然编译器将只在标准库的\n\t目录找。这个dir就是目录的名称。\n-l"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("library"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("    \n\t指定编译的时使用的库，如 gcc "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-lcurses")]),t._v(" hello.c，使用curses库编译链接，生成程序。\n")])])]),a("p",[t._v("（3）预处理选项")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-Dmacro")]),t._v("\n\t相当于C语言中的"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#define macro")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-Dmacro")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("defn\n\t定义宏，相当于C语言中的"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#define macro defn")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-Umacro")]),t._v("\n\t取消宏定义，相当于C语言中的"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#undef macro")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-undef")]),t._v("\n\t取消任何非标准宏的定义，C++标准预定义的宏仍然有效\n")])])]),a("p",[t._v("（4）链接方式选项")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-static")]),t._v("\n\t此选项将禁止使用动态库。优点：程序运行不依赖于其他库。缺点：可执行文件比较大。\n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-shared")]),t._v("\n\t此选项将尽量使用动态库，为默认选项。优点：生成文件比较小。缺点：运行时需要系统提供动态库。\n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-symbolic")]),t._v("\n\t建立共享目标文件的时候，把引用绑定到全局符号上。对所有无法解析的引用作出警告（除非用连接选项，"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'-Xlinker -z -Xlinker defs'")]),t._v("取代"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("。注：只有部分系统支持该选项。\n-Wl,option   \n\t此选项传递option给链接程序；如果option中间有逗号，就将option分成多个选项传递给链接器\n-Wl,-Bstatic\n\t告诉链接器ld只链接静态库，如果只存在动态链接库，则链接器报错。\n-Wl,-Bdynamic\n\t告诉链接器ld优先使用动态链接库，如果只存在静态链接库，则使用静态链接库\n-Wl,-rpath,"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("dir"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t指定链接器共享库查找目录为"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("dir"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n-Wl,-s 或 -Wl,--strip-all\n\t指定链接器消除所有符号信息\n-Wl,-S 或 -Wl,--strip-debug\n\t指定链接器消除调试符号信息，而非所有符号信息\n")])])]),a("p",[t._v("（5）错误与告警选项")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("-pedantic\n\t允许发出ANSI/ISO C标准所列出的所有警告\n-pedantic-errors\n\t允许发出ANSI/ISO C标准所列出的错误\n-Wall\n\t一般使用该选项，允许发出GCC能够提供的所有有用的警告。也可以用-W{warning}来标记指定的警告\n-Wno-deprecated\n\t使用C++标准废弃特性不告警\n-Werror\n\t要求GCC将所有的警告当成错误进行处理，在警告发生时中止编译过程。\n-Werror={warning}\n\t将指定警告设置为错误。例如-Werror=return-type，如果函数需要返回值却没有return语句，则编译报错\n-Wunknown-pragmas\n\t遇到GCC无法识别的编译指导指令，发出警告。在使用了-Wall选项时，就不需要使用该命令选项了\n-Wno-pragmas\n\t遇到GCC无法识别的编译指导指令，不发出警告\n-w\n\t关闭所有警告,建议不要使用此项。\n")])])]),a("p",[t._v("（6）调试选项")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" -g   \n\t指示编译器，在编译时，产生调试信息。\n-gstabs   \n\t此选项以stabs格式生成调试信息,但不包括gdb调试信息。 \n-gstabs+   \n\t此选项以stabs格式声称调试信息,并且包含仅供gdb使用的额外调试信息.   \n-ggdb    \n\t此选项将尽可能的生成gdb可以使用的调试信息。\n-glevel\n\t请求生成调试信息，同时用level指出需要多少信息，默认的level是2\n-pg\n\t编译的过程中加入额外的代码， 供性能分析工具gprof剖析程序的耗时情况\n")])])]),a("p",[t._v("（7）优化选项")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("-O0   \n-O1   \n-O2   \n-O3   \n\t编译器优化选项分为4个级别，-O0表示没有优化，-O1为缺省值，建议使用-O2，-O3优化级别最高。\n")])])]),a("p",[t._v("（8）其他选项")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("-fpic\n\t编译器生成位置无关目标码（PIC，position-independent code），用于动态链接库，即Linux下的.so文件。通过全局偏移表（GOT，Global Offset Table）访问所有常量地址。程序启动时通过动态加载程序解析GOT条目。如果链接的so文件的GOT大小超过计算机特定的最大大小，则会从链接器收到错误消息，指示-fpic不起作用。这种情况下，请使用-fPIC重新编译\n-fPIC\n\t同-fpic功能一致，生成位置无关目标码，用于生成动态链接库，建议使用该选项，而非-fpic\n-v, --verbose\n\t显示详细的编译、汇编、链接命令\n-pipe\n\t使用管道代替编译过程中的临时文件,在使用非gnu汇编工具的时候,可能有些问题   \n\tg++ -pipe -o hello.out hello.cpp\n-ansi\n\t关闭gnu c中与ansi c不兼容的特性，激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及\n\tUNIX,vax等预处理宏。\n-fno-asm   \n\t此选项实现ansi选项功能的一部分，它禁止将asm,inline和typeof用作关键字。   \n-fno-strict-prototype\n\t只对g++起作用,使用这个选项,g++将对不带参数的函数,都认为是没有显式的对参数的个数和类型说明,而不是没有\n\t参数.而gcc无论是否使用这个参数,都将对没有带参数的函数,认为没有显式说明的类型。\n-fthis-is-varialble   \n\t就是向传统c++看齐,可以使用this当一般变量使用。\n-fcond-mismatch   \n\t允许条件表达式的第二和第三参数类型不匹配,表达式的值将为void类型。\n-funsigned-char   \n-fno-signed-char   \n-fsigned-char   \n-fno-unsigned-char   \n\t这四个参数是对char类型进行设置,决定将char类型设置成unsigned char(前两个参数)或者signed char(后\n\t两个参数)。\n-fpermissive\n\t把代码的语法错误作为警告，并继续编译。请谨慎使用该选项。\n-imacros file   \n\t将file文件的宏,扩展到gcc/g++的输入文件,宏定义本身并不出现在输入文件中     \n-nostdinc   \n\t使编译器不在系统缺省的头文件目录里面找头文件,一般和-I联合使用,明确限定头文件的位置。 \n-nostdin C++\n\t规定不在g++指定的标准路经中搜索,但仍在其他路径中搜索,此选项在创建libg++库使用。\n-C\n\t在预处理的时候,不删除注释信息,一般和-E使用,有时候分析程序，用这个很方便的。 \n-m\n\t生成与具体 CPU 相关的程序。\n-mtune=cpu-type \n\t为指定类型的CPU生成代码。cpu-type 可以是：i386，i486，i586，pentium，i686，pentium4 等等。\n-m32\n\t生成 32bits 程序。int，long 和指针位宽为 32 位。\n-m64\n\t生成 64bits 程序。int 位宽为 32 位，long 和指针位宽为 64 位。\n-mmmx\n-msse\n-msse2\n-mno-mmx\n-mno-sse\n-mno-sse2\n\t使用或者不使用 MMX，SSE，SSE2 指令。\n-M\n\t生成文件依赖的信息，包含目标文件所依赖的所有源文件。你可以用gcc -M hello.c来测试一下，很简单。   \n-MM   \n\t和上面的那个一样，但是它将忽略由#include造成的依赖关系。   \n-MD\n\t和-M相同，但是输出将导入到.d的文件里面。\n-MMD   \n\t和-MM相同，但是输出将导入到.d的文件里面。\n-Wa,option   \n\t此选项传递option给汇编器；如果option中间有逗号，就将option分成多个选项传递给汇编器 \n-x language filename   \n\t设定文件所使用的语言,使后缀名无效,对以后的多个有效.也就是根据约定C语言的后缀名称是.c的，而C++的后缀\n\t名是.C或者.cpp。如果你很个性，决定你的C代码文件的后缀名是.pig，那你就要用这个参数,这个参数对他后面\n\t的文件名都起作用，除非到了下一个参数的使用。可以使用的参数有下面的这些：\n\tc,objective-c,c-header,c++,cpp-output,assembler,assembler-with-cpp。   \n\t看到英文，应该可以理解的。例子用法:   \n\tgcc -x c hello.pig\n-x none filename\n\t关掉上一个选项，也就是让gcc根据文件名后缀，自动识别文件类型，例子用法:   \n\tgcc -x c hello.pig -x none hello2.c\n")])])]),a("h2",{attrs:{id:"_4-链接注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-链接注意事项"}},[t._v("#")]),t._v(" 4.链接注意事项")]),t._v(" "),a("p",[t._v("g++ 链接库时，默认优先链接动态链接库，因为这样编译出来的程序会更小。")]),t._v(" "),a("p",[t._v("如果在链接时想混合链接静态库与动态库，有如下两种方法。")]),t._v(" "),a("p",[t._v("（1）静态链接库使用绝对路径，动态链接库使用 -l。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("g++ main.cpp "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-lpthread")]),t._v(" /usr/lib64/libboost_system.a\n")])])]),a("p",[t._v("（2）使用"),a("code",[t._v("-Wl,-Bstatic")]),t._v("告诉链接器"),a("code",[t._v("ld")]),t._v("链接静态库，不存在静态库则报错。使用"),a("code",[t._v("-Wl,-Bdynamic")]),t._v("告诉链接器优先使用动态链接库，如果只存在静态库，则使用静态库。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("g++ main.cpp -Wl,-Bstatic "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-lboost_system")]),t._v(" -Wl,-Bdynamic "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-lpthread")]),t._v("\n")])])]),a("p",[t._v("命令末尾"),a("code",[t._v("-Wl,-Bdynamic")]),t._v("，作用是告诉链接器，后续系统库的链接默认使用动态链接，否则会报找不到库的错误。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("/usr/bin/ld: cannot "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("find")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-lpthread")]),t._v("\ncollect2: ld returned "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("exit")]),t._v(" status\n")])])]),a("p",[t._v('链接时，库要放在目标文件的后面，否则会报"undefined reference to: xxx"错误。具体参见 gcc 手册的如下描述：')]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("the linker searches and processes libraries and object files in the order they are \nspecified. Thus, `foo.o -lz bar.o' searches library `z' after file foo.o but before \nbar.o. If bar.o refers to functions in `z', those functions may not be loaded.\n")])])]),a("hr"),t._v(" "),a("h2",{attrs:{id:"参考文献"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[t._v("#")]),t._v(" 参考文献")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://man7.org/linux/man-pages/man1/g++.1.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("g++(1) - Linux manual page - man7.org"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://gcc.gnu.org/onlinedocs/gcc-6.1.0/gcc.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("GCC官方手册"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"http://www.cnblogs.com/lidan/archive/2011/05/25/2239517.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("g++参数介绍"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://stackoverflow.com/questions/36353302/gcc-cannot-find-cc1plus?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa",target:"_blank",rel:"noopener noreferrer"}},[t._v("gcc cannot find cc1plus"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/zxy_cs/article/details/6901737",target:"_blank",rel:"noopener noreferrer"}},[t._v("GNU g++常用编译选项用法"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/xiangguiwang/article/details/81939237",target:"_blank",rel:"noopener noreferrer"}},[t._v("-fpic 与-fPIC的区别"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://stackoverflow.com/questions/14163208/how-to-link-c-object-files-with-ld",target:"_blank",rel:"noopener noreferrer"}},[t._v("How to link C++ object files with ld.stackoverflow"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("程序员的自我修养[M].俞甲子，石凡，潘爱民.C2.1被隐藏了的过程.P38-P41")]),t._v(" "),a("Vssue",{attrs:{title:"g++"}})],1)}),[],!1,null,null,null);a.default=e.exports}}]);
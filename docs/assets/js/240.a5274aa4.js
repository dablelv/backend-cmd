(window.webpackJsonp=window.webpackJsonp||[]).push([[240],{573:function(t,a,s){"use strict";s.r(a);var e=s(12),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-命令简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-命令简介"}},[t._v("#")]),t._v(" 1.命令简介")]),t._v(" "),a("p",[t._v("valgrind 是一套用于调试和分析程序的工具集。")]),t._v(" "),a("p",[t._v("Valgrind 工具套件提供了许多调试和分析工具，可帮助您使程序更快、更正确。 这些工具中最受欢迎的称为 Memcheck。 它可以检测 C 和 C++ 程序中常见的许多与内存相关的错误，这些错误可能导致崩溃和不可预知的行为。")]),t._v(" "),a("p",[t._v("Valgrind 通常包括如下几个工具：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Memcheck 是重量级内存检测工具。\nCachegrind 检查程序中缓存使用出现的问题。\nCallgrind 检查程序中函数调用过程中出现的问题。\nHelgrind 检测多线程中的数据竞争问题。\nDRD 也用于分析多线程。与Helgrind类似，但是用不同的分析技术，所以可以检测不同的问题。\nMassif，检查程序中堆栈使用中出现的问题。\nDHAT 是一种不同类型的堆分析器。 它可以帮助您了解块生命周期、块利用率和布局效率低下的问题。\nBBV 是一个实验性的 SimPoint 基本块向量生成器。 它对从事计算机体系结构研究和开发的人很有用。\n")])])]),a("p",[t._v("Valgrind 中包含的 Memcheck 工具可以检查以下内存错误：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.访问不应该访问的内存，如使用超过 malloc 分配的内存空间、溢出堆栈顶部、以及使用已经释放的内存（Accessing memory you shouldn't）。\n2.使用未初始化的内存 (Use of uninitialised memory)。\n3.堆内存释放不正确，如重复 free、申请和释放内存函数 malloc/free/new/delete 不匹配（Incorrect freeing of heap memory）。\n4.内存泄漏 (Memory leaks – where pointers to malloc’d blocks are lost forever)。\n5.将可疑（可能为负）值传递给内存分配函数的大小参数（Passing a fishy (presumably negative) value to the size parameter of a memory allocation function）。\n6.src 和 dst 的重叠(Overlapping src and dst pointers in memcpy() and related functions)。\n")])])]),a("p",[t._v("本文主要提供了使用 Memcheck 检测程序中的内存错误所需的最少信息。 有关 Memcheck 和其他工具的完整文档，请阅读"),a("a",{attrs:{href:"https://valgrind.org/docs/manual/manual.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("用户手册"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"_2-命令格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-命令格式"}},[t._v("#")]),t._v(" 2.命令格式")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("valgrind [valgrind-options] [your-program] [your-program-options]\n")])])]),a("h2",{attrs:{id:"_3-选项说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-选项说明"}},[t._v("#")]),t._v(" 3.选项说明")]),t._v(" "),a("p",[t._v("Valgrind 的参数分为两类，一类是 core 的参数，它对所有的工具都适用；另外一类就是具体某个工具（如 Memcheck）的参数。Valgrind 提供了大量的参数满足你特定的调试需求，具体可参考其"),a("a",{attrs:{href:"https://valgrind.org/docs/manual/manual.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("用户手册"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("p",[t._v("要想使用 Memcheck，可以在 Valgrind 命令行上指定 --tool=memcheck。 不过，不必这样做，因为 Memcheck 是 Valgrind 的默认工具。")]),t._v(" "),a("p",[t._v("首先了解下 Valgrind 的基本选项。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("-h, "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--help")]),t._v("\n\t显示所有选项的帮助，包括核心和所选工具。 如果重复该选项，则相当于给出 --help-debug。\n\t\n--help-debug\n\t和--help相同，并且还能显示通常只有Valgrind的开发人员使用的调试选项。\n\t\n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--version")]),t._v("\n\t显示 Valgrind 内核的版本号，工具可以有他们自已的版本号。有一种方案可以确保工具仅在核心版本可以使用时执行。这样可以减工具和内核之间版本不兼容导致奇怪问题的概率。\n\t\n-q, "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--quiet")]),t._v("\n\t安静地运行，只打印错误信息。在进行回归测试或者有其它的自动化测试机制时会非常有用。\n\t\n-v, "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--verbose")]),t._v("\n\t显示详细信息。在各个方面显示你的程序的额外信息，如共享对象加载，使用的抑制，执行引擎和工具的进程，异常行为的警告信息。重复这个标记可以增加详细的级别。\n\t\n--trace-children"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("yes"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("no"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("default: no"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t启用后，Valgrind 将跟踪通过 "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("exec")]),t._v(" 系统调用启动的子进程。 这对于多进程程序是必要的。\n\t\n--trace-children-skip"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("patt1,patt2,"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n\t此选项仅在指定 --trace-children"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("yes 时有效。 它允许跳过一些孩子。 该选项采用逗号分隔的模式列表，用于 Valgrind 不应跟踪的子可执行文件的名称。模式可能包括元字符 ？和 *，它们具有通常的含义。\n\t\n--trace-children-skip-by-arg"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("patt1,patt2,"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n\t这与 --trace-children-skip 相同，但有一个区别：是否跳过子进程是通过检查子进程的参数而不是其可执行文件的名称。\n\t\n--child-silent-after-fork"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("yes"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("no"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("default: no"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t启用后，Valgrind 不会显示由 fork 调用产生的子进程的任何调试或日志输出。 在处理创建子进程时，这可以使输出不那么混乱（尽管更具误导性）。 与 --trace-children 结合使用特别有用。\n\t\n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--vgdb")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("no"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("yes")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("full"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("default: yes"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t当指定 "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--vgdb")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("yes 或 "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--vgdb")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("full 时，Valgrind 将提供“gdbserver”功能。 这允许外部 GNU GDB 调试器在 Valgrind 上运行时控制和调试您的程序。 "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--vgdb")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("full 会产生显著的性能开销，但会提供更精确的断点和观察点。 有关详细说明，请参阅 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Debugging your program using Valgrind's gdbserver and GDB"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("https://valgrind.org/docs/manual/manual-core-adv.html"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#manual-core-adv.gdbserver)。")]),t._v("\n\t\n--vgdb-error"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("number"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("default: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("999999999")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t当使用 "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--vgdb")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("yes 或 "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--vgdb")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("full 启动 Valgrind gdbserver 时使用此选项。报告错误的工具将冻结程序并等待您连接 GDB 之前报告指定数量的错误。 因此，零值将导致 gdbserver 在您的程序执行之前启动。 这通常用于在执行前插入 GDB 断点，也适用于不报告错误的工具，例如 Massif。\n\t\n--vgdb-stop-at"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("set"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("default: none"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t当使用 "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--vgdb")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("yes 或 "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--vgdb")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("full 启用 Valgrind gdbserver 时使用此选项。 在报告 --vgdb-error 指定数量的错误之后，将为每个错误调用 Valgrind gdbserver。\n\t\n--track-fds"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("yes"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("no"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("all"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("default: no"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t启用后，Valgrind 将在退出或请求时通过 gdbserver 监控命令 v.info open_fds 打印出打开的文件描述符列表。 与每个文件描述符一起打印文件打开位置的堆栈回溯以及与文件描述符相关的任何详细信息，例如文件名或套接字详细信息。 使用 all 将报告输出到标准输入、标准输出和标准错误。\n\t\n--time-stamp"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("yes"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("no"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("default: no"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t启用后，每条消息前面都会显示自启动以来经过的挂钟时间，以天、小时、分钟、秒和毫秒表示。\n\t\n--log-fd"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("number"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("default: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(", stderr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t指定 Valgrind 应该将其所有消息发送到指定的文件描述符。 默认值 "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" 是标准错误通道 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("stderr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("。 请注意，这可能会干扰客户端自己对 stderr 的使用，因为 Valgrind 的输出将与客户端发送到 stderr 的任何输出交错。\n\t\n--log-file"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("filename"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t指定 Valgrind 应将其所有消息发送到指定文件。 如果文件名为空，则会导致中止。 文件名中可以使用三种特殊的格式说明符。\n\n\t%p 替换为当前进程 ID。 这对于调用多个进程的程序非常有用。\n\n\t%n 被替换为此进程唯一的文件序列号。 这对于从同一文件名模板生成多个文件的进程很有用。\n\n\t%q"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("FOO"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" 替换为环境变量 FOO 的内容。 如果 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("FOO"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" 部分格式错误，则会导致中止。 这个说明符很少需要，但在某些情况下非常有用（例如，在运行 MPI 程序时）。\n\n\t%% 替换为 %。\n\n\t如果 % 后跟任何其他字符，则会导致中止。\n\n\t如果文件名指定了相对文件名，则将其放在程序的初始工作目录中：这是程序在 fork 或 "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("exec")]),t._v(" 之后开始执行时的当前目录。\n\t\n--log-socket"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("ip-address:port-number"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t指定 Valgrind 应将其所有消息发送到指定 IP 地址的指定端口。 可以省略端口，缺省为 "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1500")]),t._v("。 如果无法与指定的套接字建立连接，Valgrind 会退回到将输出写入标准错误（stderr）。 此选项旨在与 valgrind-listener 程序结合使用。有关详细信息，请参阅手册中的 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("the commentary"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("https://valgrind.org/docs/manual/manual-core.html"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#manual-core.comment)。")]),t._v("\n")])])]),a("p",[t._v("下面给出 Memcheck 的选项说明。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("--leak-check=<no|summary|yes|full> [default: summary]\n\t启用后，在客户端程序完成时搜索内存泄漏。 如果设置为摘要，则表示发生了多少泄漏。 如果设置为 full 或 yes，每个单独的泄漏将详细显示和/或计为错误，由选项 --show-leak-kinds 和 --errors-for-leak-kinds 指定。\n\n\t如果给出 --xml=yes，memcheck 将自动使用值 --leak-check=full。 如果您对泄漏结果不感兴趣，可以使用 --show-leak-kinds=none 来减小 xml 输出的大小。\n\t\n--leak-resolution=<low|med|high> [default: high]\n\t在进行泄漏检查时，确定 Memcheck 是否愿意考虑不同的回溯是相同的，以便将多个泄漏合并到一个泄漏报告中。 当设置为 low 时，只有前两个条目需要匹配。 med 时，四个条目必须匹配。 high 时，所有条目都需要匹配。\n\n\t对于核心泄漏调试，您可能希望将 --leak-resolution=high 与 --num-callers=40 或一些如此大的数字一起使用。\n\n\t请注意， --leak-resolution 设置不会影响 Memcheck 查找泄漏的能力，只会改变结果的呈现方式。\n\n--show-leak-kinds=<set> [default: definite,possible]\n\t通过以下方式之一指定要在完整泄漏搜索中显示的泄漏类型：\n\t1.以逗号分隔的一个或多个类型 definite indirect possible reachable。\n\t2.all 指定完整的集合（所有泄漏类型）。 它相当于 --show-leak-kinds=defined,indirect,possible,reachable。\n\t3.none 表示空集。\n\n--errors-for-leak-kinds=<set> [default: definite,possible]\n\t完整泄漏搜索中指定哪种泄漏种类计为错误。 <set> 的指定类似于 --show-leak-kinds。\n\n--leak-check-heuristics=<set> [default: all]\n\t指定泄漏搜索期间要使用的泄漏检查启发式集。 启发式控制哪些指向块的内部指针导致它被认为是可访问的。 启发式集以下列方式之一指定：\n\t1.使用逗号分隔一个或多个 stdstring length64 newarray multipleinheritance。\n\t2.all 激活完整的启发式方法。 相当于 --leak-check-heuristics=stdstring,length64,newarray,multipleinheritance。\n\t3.none 表示空集。\n\n\t请注意，这些启发式方法取决于 C++ 编译器生成的对象的布局。 它们已经使用一些 gcc 版本（例如 4.4 和 4.7）进行了测试。 它们可能无法与其他 C++ 编译器一起正常工作。\n\n--show-reachable=<yes|no> , --show-possibly-lost=<yes|no>\n\t这些选项提供了另一种方法来指定要显示的泄漏类型：\n\t1.--show-reachable=no --show-possibly-lost=yes 等价于 --show-leak-kinds=definite,possible。\n\t2.--show-reachable=no --show-possibly-lost=no 等价于 --show-leak-kinds=definite。\n\t3.--show-reachable=yes 等价于 --show-leak-kinds=all。\n\n\t注意 --show-possibly-lost=no 不会生效当 --show-reachable=yes 被指定时。\n\n--xtree-leak=<no|yes> [no]\n\t如果设置为 yes，则在退出时完成的泄漏搜索结果将在“Callgrind Format”执行树文件中输出。 请注意，这会自动设置选项 --leak-check=full 和 --show-leak-kinds=all，以允许 xtree 可视化工具（例如 kcachegrind）选择要可视化的泄漏类型。生成的文件将包含以下事件：\n\tRB : Reachable Bytes\n\tPB : Possibly lost Bytes\n\tIB : Indirectly lost Bytes\n\tDB : Definitely lost Bytes (direct plus indirect)\n\tDIB : Definitely Indirectly lost Bytes (subset of DB)\n\tRBk : reachable Blocks\n\tPBk : Possibly lost Blocks\n\tIBk : Indirectly lost Blocks\n\tDBk : Definitely lost Blocks\n\n\t上述所有事件的增加或减少也将在文件中输出，以提供 2 次连续泄漏搜索之间的增量（增加或减少）。 例如，iRB 是 RB 事件的增加，dPBk 是 PBk 事件的减少。 对于完成的第一次泄漏搜索，增加和减少事件的值将为零。\n\n\t有关执行树的详细说明，请参阅 [Execution Trees](https://valgrind.org/docs/manual/manual-core.html#manual-core.xtree)。\n\n--xtree-leak-file=<filename> [default: xtleak.kcg.%p]\n\t指定 Valgrind 应在指定文件中生成 xtree 泄漏报告。 文件名中出现的任何 %p、%q 或 %n 序列都以与 --log-file 完全相同的方式展开。\n\n--undef-value-errors=<yes|no> [default: yes]\n\t控制 Memcheck 是否报告使用未定义值错误。 如果您不想看到未定义的值错误，请将其设置为 no。 它还具有一定程度上加快 Memcheck 的副作用。 AddrCheck（在 Valgrind 3.1.0 中被移除）的功能类似于带有 --undef-value-errors=no 的 Memcheck。\n\n--track-origins=<yes|no> [default: no]\n\t控制 Memcheck 是否跟踪未初始化值的来源。 默认情况下，它不会，这意味着尽管它可以告诉您未初始化的值正在以危险的方式使用，但它无法告诉您未初始化的值来自何处。 这通常使追查根本问题变得困难。\n\n\t当设置为 yes 时，Memcheck 会跟踪所有未初始化值的来源。 然后，当报告一个未初始化的值错误时，Memcheck 将尝试显示该值的来源。 源可以是以下四个位置之一：堆块、栈分配、客户端请求或其他其他源（如对 brk 的调用）。\n\n--partial-loads-ok=<yes|no> [default: yes]\n\t控制 Memcheck 如何处理32位、64位、128位和256位自然对齐的加载，这些加载来自某些字节可寻址而其他字节不可寻址的地址。如果为 yes，这样的加载不会产生地址错误。相反，来自非法地址的加载字节被标记为未初始化，而与合法地址对应的字节则以正常方式处理。\n\n\t当否时，来自部分无效地址的加载被视为与来自完全无效地址的加载相同：发出非法地址错误，并且结果字节被标记为已初始化。\n\n\t请注意，以这种方式运行的代码违反了 ISO C/C++ 标准，应视为已损坏。 如果可能的话，应该修复这样的代码。\n\n--expensive-definedness-checks=<no|auto|yes> [default: auto]\n\t控制 Memcheck 在检查某些值的定义时是否应该使用更精确但也更昂贵（耗时）的工具。 特别是，这会影响整数加法、减法和相等比较的检测。\n\n--keep-stacktraces=alloc|free|alloc-and-free|alloc-then-free|none [default: alloc-and-free]\n\t控制 malloc'd 和/或 free'd 块保留哪些栈跟踪。\n\n--freelist-vol=<number> [default: 20000000]\n\t当客户端程序使用 free（在 C 中）或 delete（C++）释放内存时，该内存不会立即用于重新分配。 相反，它被标记为不可访问并放置在已释放块的队列中。 目的是尽可能推迟释放的内存重新进入循环的时间点。 这增加了 Memcheck 在块被释放后的一段时间内能够检测到对块的无效访问的机会。\n\n\t此选项指定队列中块的最大总大小（以字节为单位）。 默认值为两千万字节。 增加此值会增加 Memcheck 使用的内存总量，但可能会检测到释放块的无效使用，否则这些释放块将无法检测到。\n\n--freelist-big-blocks=<number> [default: 1000000]\n\t当释放块队列中的块可用于重新分配时，Memcheck 将优先重新循环大小大于或等于 --freelist-big-blocks 的块。 这确保了释放大块（特别是释放大于 --freelist-vol 的块）不会立即导致空闲列表中所有（或很多）小块的重新循环。 换句话说，这个选项增加了发现“小”块的悬空指针的可能性，即使在大块被释放时也是如此。\n\n\t将值设置为 0 意味着所有块都按 FIFO 顺序重新循环。\n\n--workaround-gcc296-bugs=<yes|no> [default: no]\n\t启用后，假设在栈指针下方一小段距离的读取和写入是由于 GCC 2.96 中的错误导致的，并且不报告它们。 “小距离”默认为 256 字节。 请注意，GCC 2.96 是一些古老的 Linux 发行版（RedHat 7.X）的默认编译器，因此您可能需要使用此选项。 如果没有必要，请不要使用它，因为它可能会导致真正的错误被忽略。更好的选择是使用更新的 GCC，其中修复了此错误。\n\n--ignore-range-below-sp=<number>-<number>\n\t这是对已弃用的 --workaround-gcc296-bugs 选项的更通用替代。 指定时，它会导致 Memcheck 不报告堆栈指针下方指定偏移量的访问错误。 这两个偏移量必须是十进制正数，并且有点违反直觉，第一个偏移量必须更大，以暗示要忽略的非环绕地址范围。 例如，要忽略堆栈指针下方 8192 字节处的 4 字节访问，请使用 --ignore-range-below-sp=8192-8189。 只能指定一个范围。\n\n--show-mismatched-frees=<yes|no> [default: yes]\n\t启用后，Memcheck 使用与分配函数匹配的函数检查堆块是否被释放。 也就是说，它期望 free 用于释放 malloc 分配的块，delete 用于 new 分配的块，delete[] 用于 new[] 分配的块。 如果检测到不匹配，则会报告错误。 这通常很重要，因为在某些环境中，使用不匹配的函数释放可能会导致崩溃。\n\n\t然而，有一种情况是无法避免这种不匹配的。 那是当用户提供调用 malloc 的 new/new[] 和调用 free 的 delete/delete[] 的实现时，这些函数是不对称内联的。 例如，假设 delete[] 是内联的，但 new[] 不是。 结果是 Memcheck 将所有 delete[] 调用“视为”对 free 的直接调用，即使程序源不包含不匹配的调用。\n\n\t这会导致很多令人困惑和不相关的错误报告。 --show-mismatched-frees=no 禁用这些检查。 但是，通常不建议禁用它们，因为您可能会因此错过真正的错误。\n\n--ignore-ranges=0xPP-0xQQ[,0xRR-0xSS]\n\tMemcheck 的可寻址性检查将忽略此选项中列出的任何范围（并且可以指定多个范围，用逗号分隔）。\n\n--malloc-fill=<hexnumber>\n\t用指定的字节填充由 malloc、new 等分配的块，而不是由 calloc 分配的块。 当试图摆脱模糊的内存损坏问题时，这可能很有用。 Memcheck 仍然认为分配的区域是未定义的——这个选项只影响它的内容。 请注意，当 --malloc-fill 用作客户端请求 VALGRIND_MEMPOOL_ALLOC 或 VALGRIND_MALLOCLIKE_BLOCK 的参数时，它不会影响内存块。\n\n--free-fill=<hexnumber>\n\t用指定的字节值填充由 free、delete 等释放的块。 当试图摆脱模糊的内存损坏问题时，这可能很有用。Memcheck 仍然认为访问已释放的区域无效，此选项仅影响其内容。 请注意，当 --free-fill 用作客户端请求 VALGRIND_MEMPOOL_FREE 或 VALGRIND_FREELIKE_BLOCK 的参数时，它不会影响内存块。\n")])])]),a("h2",{attrs:{id:"_4-常用示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-常用示例"}},[t._v("#")]),t._v(" 4.常用示例")]),t._v(" "),a("p",[t._v("为了使 Valgrind 发现的错误更精确，如能够定位到源代码行，建议在编译 C 和 C++ 程序时加上 -g 参数，编译优化选项请选择 O0，虽然这会降低程序的执行效率。")]),t._v(" "),a("h3",{attrs:{id:"_4-1-内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-内存泄漏"}},[t._v("#")]),t._v(" 4.1 内存泄漏")]),t._v(" "),a("p",[t._v("Valgrind 可以用来检测程序在哪个位置发生内存泄漏，例如下面的程序：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdlib.h>")])]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("array "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("编译程序时，需要加上-g选项：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("$ gcc "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-g")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" main main.c\n")])])]),a("p",[t._v("使用 Valgrind 检测内存使用情况：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("$ valgrind "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--tool")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("memcheck --leak-check"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("full  ./main\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Memcheck, a memory error detector\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Copyright "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("C"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2002")]),t._v("-2017, and GNU GPL'd, by Julian Seward et al.\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Using Valgrind-3.13.0 and LibVEX"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" rerun with "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-h")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" copyright info\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Command: ./main_c\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" HEAP SUMMARY:\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("     "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" use at exit: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" bytes "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" blocks\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("   total heap usage: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" allocs, "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" frees, "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" bytes allocated\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" bytes "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" blocks are definitely lost "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" loss record "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" of "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    at 0x4C2DBF6: malloc "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vg_replace_malloc.c:299"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    by 0x400537: main "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("main.c:4"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" LEAK SUMMARY:\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    definitely lost: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" bytes "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" blocks\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    indirectly lost: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" bytes "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" blocks\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("      possibly lost: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" bytes "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" blocks\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    still reachable: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" bytes "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" blocks\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("         suppressed: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" bytes "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" blocks\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" For counts of detected and suppressed errors, rerun with: "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-v")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31416")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" ERROR SUMMARY: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" errors from "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" contexts "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("suppressed: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" from "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("先看看输出信息中的 HEAP SUMMARY，它表示程序在堆上分配内存的情况，其中的1 allocs表示程序分配了 1 次内存，0 frees 表示程序释放了 0 次内存，4 bytes allocated 表示分配了 4 个字节的内存。")]),t._v(" "),a("p",[t._v("另外，Valgrind 也会报告程序是在哪个位置发生内存泄漏。例如，从下面的信息可以看到，程序发生了一次内存泄漏，位置是 main.c 文件的第 4 行：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("==31416== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1\n==31416==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)\n==31416==    by 0x400537: main (main.c:4)\n")])])]),a("h3",{attrs:{id:"_4-2-内存越界"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-内存越界"}},[t._v("#")]),t._v(" 4.2 内存越界")]),t._v(" "),a("p",[t._v("C/C++ 程序经常出现的 Bug 就是数组越界访问，例如下面的 C++ 程序出现了越界访问：")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<vector>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<iostream>")])]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("vector"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("v")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("cout "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("endl"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("使用 Valgrind 分析这段程序，Valgrind 会提示越界访问：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("$ g++ "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-std")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("c++11 "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-g")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" main main.cpp\n$ valgrind "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--tool")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("memcheck --leak-check"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("full ./main\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31523")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Memcheck, a memory error detector\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31523")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Copyright "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("C"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2002")]),t._v("-2017, and GNU GPL"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'d, by Julian Seward et al.\n==31523== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==31523== Command: ./main\n==31523==\n==31523== Invalid read of size 4\n==31523==    at 0x400AD7: main (main.cpp:7)\n==31523==  Address 0x5ab5ca8 is 0 bytes after a block of size 40 alloc'")]),t._v("d\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31523")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    at 0x4C2E216: operator new"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("unsigned long"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vg_replace_malloc.c:334"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31523")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    by 0x4010D3: __gnu_cxx::new_allocator"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("::allocate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("unsigned long, void const*"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("new_allocator.h:104"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31523")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    by 0x401040: std::allocator_traits"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("std::allocator"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("::allocate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("std::allocator"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">&")]),t._v(", unsigned long"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("alloc_traits.h:491"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31523")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    by 0x400F91: std::_Vector_base"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int, std::allocator"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("::_M_allocate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("unsigned long"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("stl_vector.h:170"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31523")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    by 0x400E7E: std::_Vector_base"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int, std::allocator"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("::_M_create_storage"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("unsigned long"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("stl_vector.h:185"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31523")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    by 0x400D1E: std::_Vector_base"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int, std::allocator"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("::_Vector_base"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("unsigned long, std::allocator"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" const"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("stl_vector.h:136"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31523")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    by 0x400C11: std::vector"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int, std::allocator"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("::vector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("unsigned long, int const"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(", std::allocator"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("int"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" const"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("stl_vector.h:291"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31523")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    by 0x400AB9: main "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("main.cpp:6"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("Invalid read of size 4 表示越界读取 4 个字节，这个操作出现在 main.cpp 文件的第 6 行。另外可以看到，vector 分配了一块 40 字节的内存，程序越界访问这块内存之后的 4 个字节。")]),t._v(" "),a("h3",{attrs:{id:"_4-3-内存覆盖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-内存覆盖"}},[t._v("#")]),t._v(" 4.3 内存覆盖")]),t._v(" "),a("p",[t._v("C 语言的强大和可怕之处在于其可以直接操作内存，C 标准库中提供了大量这样的函数，比如 strcpy, strncpy, memcpy, strcat 等，这些函数有一个共同的特点就是需要设置源地址 (src)，和目标地址(dst)，src 和 dst 指向的地址不能发生重叠，否则结果将不可预期。")]),t._v(" "),a("p",[t._v("下面就是一个 src 和 dst 发生重叠的例子。src 和 dst 所指向的地址相差 20，但指定的拷贝长度却是 21，这样就会把之前的拷贝值覆盖。")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<string.h>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdlib.h>")])]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("50")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("50")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("strncpy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("strncpy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("21")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("使用 Valgrind 分析这段程序，Valgrind 会提示内存覆盖：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("$ gcc "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-g")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" main main.c\n$ valgrind "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--tool")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("memcheck --leak-check"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("full ./main\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2976")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Source and destination overlap "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" strncpy"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("0xfff0003f9, 0xfff0003e5, "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("21")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2976")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" at 0x4C31626: __strncpy_sse2_unaligned "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2976")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" by 0x400608: main "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("main.c:12"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("输出结果显示上述程序中第 12 行，源地址和目标地址设置出现重叠。准确的发现了上述问题。")]),t._v(" "),a("h3",{attrs:{id:"_4-4-使用未初始化的值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-使用未初始化的值"}},[t._v("#")]),t._v(" 4.4 使用未初始化的值")]),t._v(" "),a("p",[t._v("另一种经常出现的 Bug，就是程序访问了未初始化的内存。")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<iostream>")])]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("cout "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"X is zero"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("endl"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("使用 Valgrind 检测这个程序：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("$ g++ "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-std")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("c++11 "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-g")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" main main.cpp\n$ valgrind "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--tool")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("memcheck --leak-check"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("full ./main\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31554")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Memcheck, a memory error detector\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31554")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Copyright "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("C"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2002")]),t._v("-2017, and GNU GPL'd, by Julian Seward et al.\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31554")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Using Valgrind-3.13.0 and LibVEX"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" rerun with "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-h")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" copyright info\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31554")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Command: ./main\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31554")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31554")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Conditional jump or move depends on uninitialised value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("31554")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("    at 0x400852: main "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("main.cpp:6"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("输出中提示了 main.cpp 文件的第 6 行访问了未初始化的内存。")]),t._v(" "),a("h3",{attrs:{id:"_4-5-内存申请与释放函数不匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-内存申请与释放函数不匹配"}},[t._v("#")]),t._v(" 4.5 内存申请与释放函数不匹配")]),t._v(" "),a("p",[t._v("内存申请与释放函数不匹配，如 C++ 程序中使用 malloc 申请内存，但错误地使用 delete 去释放，那么 Valgrind 也可以检测出来。")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdlib.h>")])]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tp "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("perror")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"malloc failed"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"address [0x%p]\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),t._v(" p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("使用 Valgrind 检测这个程序。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("$ g++ "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-g")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),t._v(" main main.cpp\n$ valgrind "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--tool")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("memcheck --leak-check"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("full ./main\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10305")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Mismatched tree"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" / delete / delete "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10305")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" at Ox4C2F2413: operator delete"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("void*"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10305")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" by 0x400725: main "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("main.cpp:11"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10305")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Aodrexs—Ox5aooco0 size "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" alloc'd\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10305")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" at Ox4C2088F: malloc "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10305")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" by Ox4006EE: main "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("main.cpp:6"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n")])])]),a("p",[t._v("在 C++ 中，以与分配方式匹配的方式释放内存非常重要。")]),t._v(" "),a("ul",[a("li",[t._v("如果使用 malloc、calloc、realloc、valloc 或 memalign 分配，则必须使用 free 释放。")]),t._v(" "),a("li",[t._v("如果使用 new 分配，则必须使用 delete 释放。")]),t._v(" "),a("li",[t._v("如果使用 new[] 分配，则必须使用 delete[] 释放。")])]),t._v(" "),a("h2",{attrs:{id:"_5-小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-小结"}},[t._v("#")]),t._v(" 5.小结")]),t._v(" "),a("p",[t._v("内存泄露检测包括动态内存使用的规范性，根本的解决办法是程序员保持良好的编码习惯，使用动态内存时谨慎考虑，保证申请与释放的必然性。因为，一些隐晦的问题可能需要在特定条件下才会引起内存泄露，依赖于检测工具也是需要长时间运行软件才能发现。")]),t._v(" "),a("p",[t._v("Valgrind memcheck 工具更多是用于检测内存泄露、内存非法访问、重复释放等问题，会引系统段错误，使用 GDB 结合系统产生的 core dump 文件，也能快速定位到调用位置。而内存泄露不会立即导致系统异常，只有运行一定时间后系统申请不到内存时才会引起异常。因此，借助 Valgrind memcheck 工具来检测内存泄露是一个高效的方法之一。")]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"参考文献"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[t._v("#")]),t._v(" 参考文献")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://valgrind.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Valgrind Home"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://man7.org/linux/man-pages/man1/valgrind.1.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("valgrind(1) - Linux manual page - man7.org"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/56538645",target:"_blank",rel:"noopener noreferrer"}},[t._v("内存检测王者之剑—valgrind - 知乎专栏"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"http://senlinzhan.github.io/2017/12/31/valgrind/",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用Valgrind 检测C++ 内存泄漏 - Senlin's Blog"),a("OutboundLink")],1)]),t._v(" "),a("Vssue",{attrs:{title:"valgrind"}})],1)}),[],!1,null,null,null);a.default=n.exports}}]);